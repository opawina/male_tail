# male_tail
###### Read last N lines from file like tail. `-f` method allowed.

### eg: `$ male_tail [-f][-n N] --path path/to/file`

### `-f`            - realtime reading
### `-n N`          - lines count to read
### `--path PATH`   - path to log file


### Технические решения:
Идея в том чтоб читать файл сразу с какого-то места в конце файла.
Место подбирается динамически по формуле `lines_count * line_length_bytes`.
Если взяли меньше строк чем необходимо - увеличиваем `line_length_bytes * 2`

(0. Не вижу причин использовать ООП тут. Избыточно. Но если очень хочется, то можно.
Первый коммит - готовое решение в скриптовом стиле))
1. `argparse` - в качестве библиотеки для человеческого интерфейса.
Входит в стандартную библиотеку - меньше проблем с зависимостями.
2. Читаем файл в байтовом режиме чтоб можно было произвольно двигать указатель.  
3. `for line in file:` - Экономим память читая из файла по строчке из генератора а не вычитываем 
весь файл в память.
4. `result_list = []` - буферизируем необходимое количество строк для итогового вывода.
5. `result_list = result_list[-lines_count:]` - Слайсы работают O(N) по скорости и по памяти.
В нашем случае это уместно. 
6. `sys.stdout.write()` - выводим всё в strout явно.


###  Испытания:
Тестировалось на машине: 
- Ubuntu 22.04.1 LTS 5.15.0-47-generic #51-Ubuntu SMP x86_64 GNU/Linux.
- 4 ядра \ 8 потоков. 
- 16Гб.

Скорость работы сопоставима с оригинальным tail. Испытания проводились на файле в 500_000
строк, весом 2.7Гб (смотри producer_test_file.py). 

#### Производительность:
`$ ./male_tail.py  --path test.txt -n 5000`    ~ 35 секунды занимает вывод в терминал

`$ tail -n 5000 test.txt`                        ~ 29 секунды занимает вывод в терминал

#### Память
Потребление памяти приемлемо. Файл в 2.7Гб не вычитвается в память целиком. Во время работы 
вышеуказанного примера занималось <300Мб памяти.
